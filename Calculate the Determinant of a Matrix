(*finds the determinant of a matrix using the Leibniz formula*)
(*finds determinant using Laplace's forumula*)(*faster*)


(*Leibniz*)
myDet2[A_] := 
  Module[{
    a, b, i, S, Seta,
    WhereIam, HowLongCycleIs, Perm,
    WhereIStarted, InversionCount,
    AccountedFor, Setn, answer,
    debug = False},
   
   If[SquareMatrixQ[A] == False,
    Return["Cannot find the determinant of a non square matrix"];
    ];
   
   answer = 0;
   Setn = {};
   Print[MatrixForm[A]];
   
   (*this creates a set of numbers from 1 to a, 
   where a is the length of the matrix*)
   For[a = 1, a <= Length[A], a++,
    Setn = Append[Setn, a];
    ];(*end for loop*)
   
   If[debug == True,
    Print["This is Setn"];
    Print[Setn];
    ];(*end debug*)
   
   S = Permutations[Setn];
   
   If[debug == True,
    Print[
     "This is \!\(\*SubscriptBox[\(S\), \(n\)]\) where n is the \
length of the matrix"];
    Print[S];
    ];(*end debug*)
   
   For[ i = 1, i <= Length[S], i++,
    
    (*is the permutation being worked on*)
    Perm = Part[S, i];
    AccountedFor = Setn;
    InversionCount = 0;
    WhereIStarted = 1;
    
    If[debug == True,
     Print["This is the permutation being worked on"];
     Print[Perm];
     ];(*end debug*)
    
    (*these while loops will count the amount of inversions a \
permutation does*)
    (****************************************************************)

    
    While[AccountedFor != {},
     
     AccountedFor = DeleteCases[AccountedFor, WhereIStarted];
     WhereIam = Perm[[WhereIStarted]];
     HowLongCycleIs = 1;
     
     If[debug == True,
      Print["This is the accounted for list"];
      Print[AccountedFor];
      Print["WhereIam"];
      Print[WhereIam];
      ];(*end debug*)
     
     While[WhereIam != WhereIStarted,
      HowLongCycleIs = HowLongCycleIs + 1;
      AccountedFor = DeleteCases[AccountedFor, WhereIam];
      WhereIam = Perm[[WhereIam]];
      
      If[debug == True,
       Print["This is how long the cycle is"];
       Print[HowLongCycleIs];
       Print["Where i am"];
       Print[WhereIam];
       Print["perm[[whereiam]]"];
       Print[Perm[[WhereIam]]];
       Print["Accountedfor"];
       Print[AccountedFor];
       ];(*end debug*)
      
      ];(*end inner while loop*)
     
     InversionCount = InversionCount + HowLongCycleIs - 1;
     (*this if statement prevents an error message from popping up \
for when*)
     (*accountedfor is the empty set and is still going through the \
loop*)
     If[AccountedFor != {},
      WhereIStarted = AccountedFor[[1]];
      ];(*end if*)
     
     ];(*end outer while loop*)
    (********************************************************************)
\

    
    If[debug == True,
     Print["This is the inversion count for the current permutation"];
     Print[InversionCount];
     ];(*end if*)
    
    (*this is the step to find out what sgn (sigma) is in the formula*)
\

    (*make a while loop that track all of the times the permutation \
does an inversion*)
    
    Seta = 1;
    
    (*this for loop gets all the a's multiplied together*)
    For[b = 1, b <= Length[Perm], b++,
     Seta = Seta*A[[b, Perm[[b]]]];
     
     If[debug == True,
      Print["This is A[[b,Perm[[b]]]]"];
      Print[A[[b, Perm[[b]]]]];
      ];(*end debug*)
     
     ];(*end for*)
    
    answer = answer + (-1)^InversionCount*Seta;
    
    ];(*end for loop*)
   
   Return[answer];
   ];



(*Laplace*)
myDet3[A_] :=
  Module[{answer, a, b, B, c, d, i, j, k, val1, val2, col, colset, 
    counter, det, cProd, debug = True},
   
   If[SquareMatrixQ[A] == False,
    Return["Please input a square matrix"];
    ];(*end if statement*)
   
   Print[MatrixForm[A]];
   B = A;
   
   (*While [ B\[NotEqual] UpperTriangularize[B],*)
   
   For[a = 1, a <= Length[A], a++,
    
    colset = {};
    
    If[A[[a]] == 0*A[[1]],
     Print["There is a zero row, therefore the determinant is zero"];
     Return[0];
     ];(*end if*)
    
    
    For[b = 1, b <= Length[A], b++,
     
     col = A[[b, a]];
     colset = Append[colset, col];
     
     If[Length[colset] == Length[A],
      
      If[colset == 0*A[[1]],
        Print[
         "There is a zero column, therefore the determinant is 0"];
        Return[0];
         ];(*end inner if*)
      
      ];(*end outer if*)
     
     If [ a != b,
      
      If [debug == False,
       Print["This first is part a of A and part b of B"];
       Print[A[[a]]];
       Print[A[[b]]];
       ];(*end debug*)
      
      If [A[[a]] == A[[b]],
       Print[
        "There is two of the same row in the matrix, so the \
determinant is 0"];
       Return[0];
       ];(*end inner if*)
      ];(*end outer if*)
     ];(*end inner for*)
    ];(*end outer for*)
   
   (*all of this will evaluate the matrix and see if there are \
obvious signs that the*)
   (*determinant will be 0*)
   (*the following code will reduce the matrix into echelon form and \
figure out the determinant of the matrix*)
   
   (*This portion makes sure there is a number in the diagonal that \
is not equal to 0*)
   (*this portion is about the type 1 elementary matrix*)
   counter = 0;
   For[c = 1, c <= Length[A], c++,
    
    If[B[[c, c]] == 0,
      
      For[d = c, d <= Length[A], d++,
        
        If[B[[c, d]] != 0,
          
          (*this is the code where it swaps the rows in a matrix*)
          B[[{c, d}]] = B[[{d, c}]];
          counter = counter + 1;
          
          If [debug == True,
           
           
           Print["There was a row swap, the new matrix is below and \
under that is the counter"];
           Print[MatrixForm[B]];
           Print[counter];
           
           ];
          
          ];(*end inner if*)
        ];(*end inner for*)
      ];(*end outer if*)
    ];(*end outer for*)
   
   
   If[debug == False,
    Print["This is how many row swaps the program performed"];
    Print[counter];
    Print["This is the current matrix being worked on"];
    Print[MatrixForm[B]];
    ];(*end debug*)
   
   (*this is the start of elementary matrix II*)
   (*This looks to see if there are numerical values other than 0 \
underneath a *)
   (*given point in the diagonal*)
   cProd = 1;
   
   For[j = 1, j <= Length[A], j++,
    For[k = 1, k <= Length[A], k++,
      
      If[j < k,
        
        If[B[[k, j]] != 0,
          val1 = B[[k, j]];
          val2 = B[[j, j]];
          cProd = cProd*val1/val2;
          B[[k]] = B[[k]] - val1/val2*B[[j]];
          
          
          ];(*end inner if*)
        ]; (*end  outer if*)
      ]; (*end inner for*)
    ]; (*end outer for*)
   
   (*this small for loop multiplies all the diagonal entries together*)

   
   det = 1;
   For[i = 1, i <= Length[A], i++,
    det = det*B[[i, i]];
    
    ];(*end for loop*)
   
   answer = (det*(-1)^counter)/cProd;
   Return[det];
   
   ];(*end module*)
